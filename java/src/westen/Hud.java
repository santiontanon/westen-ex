/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package westen;

import PNGtoMSX.ConvertPatternsToAssembler;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;
import util.Pletter;
import util.Z80Assembler;
import util.ZX0Wrapper;

/**
 *
 * @author santi
 */
public class Hud {
    public static int TOLERANCE = 64;
    
    public static void main(String args[]) throws Exception
    {
        generate(true);
    }

    
    public static void generate(boolean EXversion) throws Exception
    {
        String hudFileName = "data/hud.png";
        String titleFileName = "data/title.png";
        String objectsFileName = "data/objects.png";
        String tutorialFileName = "data/tutorial.png";
        String endingFileName = "data/housemap.png";
        String hudPath_output = "src/autogenerated/";
        
        ConvertPatternsToAssembler.MSX1Palette = Walls.MSX1Palette;
        
        generateData(hudFileName, 0, 0, 32, 7, hudPath_output + "hud", -1, false);
        generateData(hudFileName, 0, 10, 32, 7, hudPath_output + "hud-ex", -1, false);
        generateData(titleFileName, 0, 55, 32, 8, hudPath_output + "title", -1, false);
//        generateData(titleFileName, 0, 55+9, 32, 9, hudPath_output + "title", -1, false);
        generateDataWithoutNameTable(titleFileName, 0, 34, 8, 2, hudPath_output + "braingames");
        generateData(objectsFileName, 96/8, 144/8, 5, 6, hudPath_output + "pentagram-clue", -1, false);

        generateData(tutorialFileName, 0, 4, 20, 12, hudPath_output + "tutorial", -1, false);

        generateData(hudFileName, 0, 7, 8, 3, hudPath_output + "password-lock", -1, false);

        generateData(endingFileName, 256/8, 64/8, 13, 3, hudPath_output + "ending-scroll", -1, false);
        generateData(endingFileName, 152/8, 72/8, 12, 12, hudPath_output + "ending-map1", -1, false);
        generateData(endingFileName, 168/8, 0, 8, 9, hudPath_output + "ending-map2", -1, false);
        if (EXversion) {
            generateData(endingFileName, 160/8, 176/8, 11, 11, hudPath_output + "ending-map3", -1, false);
            generateData(endingFileName, 256/8, 176/8, 12, 10, hudPath_output + "ending-map4", -1, false);        
        } else {
            generateData(endingFileName, 160/8, 176/8, 11, 10, hudPath_output + "ending-map3", -1, false);
        }
        generateData(endingFileName, 248/8, 0, 7, 2, hudPath_output + "ending-the-end", -1, false);
        
        if (EXversion) {
            String puzzleAltarFileName = "data/puzzle-altar.png";
            generateData(puzzleAltarFileName, 0, 0, 23, 9, hudPath_output + "puzzle-altar", 4, true);

            String puzzleBoxFileName = "data/puzzle-box.png";
            generateData(puzzleBoxFileName, 0, 0, 8, 8, hudPath_output + "puzzle-box", 6, true);

            generateData(objectsFileName, 48/8, 400/8, 5, 6, hudPath_output + "pentagram-clue2", -1, false);
            
            // Ending vignettes:
            generateVignetteData(endingFileName, 368/8, 168/8,  0,   0, 3,  0, hudPath_output + "ending-vignette1");
            generateVignetteData(endingFileName, 368/8, 8/8,   88,  56, 1,  9, hudPath_output + "ending-vignette2");
            generateVignetteData(endingFileName, 368/8, 88/8, 176, 112, 2, 20, hudPath_output + "ending-vignette3");
        }
    }

    
    private static void generateData(
            String hudFileName,
            int startx, int starty,
            int width, int height,
            String outputFileName,
            int uniformAttribute,
            boolean flipAttributes) throws Exception {
        BufferedImage img = ImageIO.read(new File(hudFileName));
        
        List<Integer> data = new ArrayList<>();        
        List<List<Integer>> tiles = new ArrayList<>();
        int nameTable[][] = new int[width][height];
        
        extractTilesAndNameTable(img, startx, starty, width, height, uniformAttribute, flipAttributes, data, tiles, nameTable);

        System.out.println("generateHudData, nTiles: " + tiles.size());
        System.out.println("generateHudData, data size: " + data.size());

        
        Z80Assembler.dataToBinary(data, outputFileName+".bin");
        Pletter.intMain(new String[]{outputFileName+".bin", outputFileName+".plt"});
        ZX0Wrapper.main(outputFileName+".bin", outputFileName+".zx0", true, false);
    }
    


    private static void generateDataWithoutNameTable(
            String letterFileName,
            int startx, int starty,
            int width, int height,
            String outputFileName) throws Exception {
        BufferedImage img = ImageIO.read(new File(letterFileName));
        
        List<Integer> data = new ArrayList<>();
        List<List<Integer>> tiles = new ArrayList<>();
                
        for(int i = 0;i<height;i++) {
            for(int j = 0;j<width;j++) {
                List<Integer> tileData = new ArrayList<>();
                tileData.addAll(ConvertPatternsToAssembler.generateAssemblerPatternBitmap(j+startx, i+starty, img, TOLERANCE));
                tileData.addAll(ConvertPatternsToAssembler.generateAssemblerPatternAttributes(j+startx, i+starty, img, TOLERANCE));                
                tiles.add(tileData);
            }
            System.out.println("");
        }
                        
        // Generate data:
        for(List<Integer> tile:tiles) {
            data.addAll(tile);
        }

        System.out.println("generateLetterData, nTiles: " + tiles.size());
        System.out.println("generateLetterData, data size: " + data.size());

        
        Z80Assembler.dataToBinary(data, outputFileName+".bin");
        Pletter.intMain(new String[]{outputFileName+".bin", outputFileName+".plt"});
        ZX0Wrapper.main(outputFileName+".bin", outputFileName+".zx0", true, false);
    }  
    
    
    public static void extractTilesAndNameTable(
            BufferedImage img,
            int startx, int starty,
            int width, int height,
            int uniformAttribute,
            boolean flipAttributes,
            List<Integer> data,
            List<List<Integer>> tiles,
            int nameTable[][]) throws Exception
    {
                
        for(int i = 0;i<height;i++) {
            for(int j = 0;j<width;j++) {
                List<Integer> tileData = new ArrayList<>();
                tileData.addAll(ConvertPatternsToAssembler.generateAssemblerPatternBitmap(j+startx, i+starty, img, TOLERANCE));
                if (flipAttributes) {
                    for(int k = 0;k<8;k++) {
                        tileData.set(k, tileData.get(k) ^ 0xff);
                    }
                }
                if (uniformAttribute >= 0) {
                    for(int k = 0;k<8;k++) {
                        tileData.add(uniformAttribute);
                    }
                } else {
                    tileData.addAll(ConvertPatternsToAssembler.generateAssemblerPatternAttributes(j+startx, i+starty, img, TOLERANCE));
                }
                
                int tile = Walls.findTile(tileData, tiles);
                if (tile == -1) {
                    tile = tiles.size();
                    tiles.add(tileData);
                }
                nameTable[j][i] = tile;
                data.add(tile);
                
                System.out.print(tile + "\t");
            }
            System.out.println("");
        }
                        
        // Generate data:
        for(List<Integer> tile:tiles) {
            data.addAll(tile);
        }        
    }
    
    
    public static void generateVignetteData(
            String vignetteFileName,
            int startx, int starty,
            int screenx, int screeny,
            int vigneteID,  // used to add hints about sprite positions
            int nSpritesToSkip,
            String outputFileName) throws Exception {

        BufferedImage img = ImageIO.read(new File(vignetteFileName));
        
        // extract tiles:
        int width = 10;
        int height = 10;
        List<Integer> data = new ArrayList<>();        
        List<List<Integer>> tiles = new ArrayList<>();
        int nameTable[][] = new int[width][height];
        extractTilesAndNameTable(img, startx + width*2, starty, width, height, -1, false, data, tiles, nameTable);
        
        int len = data.size();
        data.add(0,len/256);
        data.add(0,len%256);
        
        // extract sprites:
        int bgColor = ConvertPatternsToAssembler.findMSXColor(startx*8 + width*8, starty*8, img, TOLERANCE);
        System.out.println("bg color: " + bgColor);
        int nSprites = 0;
        List<Integer> spriteData = new ArrayList<>();
        List<Integer> attributeData = new ArrayList<>();
        for(int y = 0;y<height*8;y++) {
            for(int x = 0;x<width*8;x++) {
                int color = ConvertPatternsToAssembler.findMSXColor(startx*8 + width*8 + x, starty*8 + y, img, TOLERANCE);
                if (color != bgColor) {
                    // align to a 4x4 grid, which happens to minimize the # of sprites
                    // in our cases, with just a few hints:
                    while((x % 4) != 0) x--;
                    while((y % 4) != 0) y--;
                    if (vigneteID == 1) {
                        // sprite position hints:
                        if (x == 40 && y == 16 && color == 11) {
                            x = 28;
                        } else if (x == 16 && y == 28 && color == 11) {
                            y = 24;
                        } else if (x == 56 && y == 32 && color == 5) {
                            x = 48;
                        } else if (x == 40 && y == 56 && color == 5) {
                            x = 36;
                        }
                    } else if (vigneteID == 3) {
                        if (x == 40 && y == 16 && color == 11) {
                            x = 32;
                        } else if (x == 52 && y == 8 && color == 0) {
                            x = 48;
                        } else if (x == 40 && y == 48 && color == 0) {
                            x = 32;
                        }
                    }
                    // new sprite!
                    Sprites.getSpriteWithColor(startx*8 + width*8 + x, starty*8 + y, img, color, spriteData);
                    // Clear the sprite area:
                    for(int yy = 0;yy<16;yy++) {
                        for(int xx = 0;xx<16;xx++) {
                            int color2 = ConvertPatternsToAssembler.findMSXColor(startx*8 + width*8 + x + xx, starty*8 + y + yy, img, TOLERANCE);
                            if (color2 == color) {
                                ConvertPatternsToAssembler.setMSXColor(img, startx*8 + width*8 + x + xx, starty*8 + y + yy, bgColor);
                            }
                        }
                    }
                    if (color == 0) color = 1;
                    System.out.println("new sprite: " + x + ", " + y + " with color " + color + " ("+ConvertPatternsToAssembler.MSXColorNames[color]+")");
//                    attributeData.add(y-1 + screeny);
//                    attributeData.add(x + screenx);
//                    attributeData.add((nSprites + nSpritesToSkip)*4);
//                    attributeData.add(color);
                    attributeData.add(0,color);
                    attributeData.add(0,(nSprites + nSpritesToSkip)*4);
                    attributeData.add(0,x + screenx);
                    attributeData.add(0,y-1 + screeny);
                    nSprites++;
                }
            }
        }
        
        data.add(spriteData.size()%256);
        data.add(spriteData.size()/256);
        data.addAll(spriteData);

        data.add(attributeData.size()%256);
        data.add(attributeData.size()/256);
        data.addAll(attributeData);
        
        System.out.println("nSprites: " + nSprites);
                
        // Save it:
        Z80Assembler.dataToBinary(data, outputFileName+".bin");
        Pletter.intMain(new String[]{outputFileName+".bin", outputFileName+".plt"});
        ZX0Wrapper.main(outputFileName+".bin", outputFileName+".zx0", true, false);
    }
}
