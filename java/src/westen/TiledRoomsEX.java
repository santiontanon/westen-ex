/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package westen;

import PNGtoMSX.ConvertPatternsToAssembler;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.imageio.ImageIO;
import util.Tiled;
import util.Z80Assembler;
import util.ZX0Wrapper;

/**
 *
 * @author santi
 */
public class TiledRoomsEX {
    public static final int TOLERANCE = 64;
    
    public static void main(String args[]) throws Exception
    {
        String room1Path = "data/tiled-rooms/street1.tmx";
        String room2Path = "data/tiled-rooms/street2.tmx";
        String room3Path = "data/tiled-rooms/street3.tmx";
        String tilesImagePath = "data/tiled-rooms/tiles.png";
        
        ConvertPatternsToAssembler.MSX1Palette = Walls.MSX1Palette;
        
        int room1[][] = Tiled.loadTMXtileData(room1Path);
        int room2[][] = Tiled.loadTMXtileData(room2Path);
        int room3[][] = Tiled.loadTMXtileData(room3Path);
        BufferedImage img = ImageIO.read(new File(tilesImagePath));
        int width = img.getWidth()/8;        
        
        List<List<Integer>> tiles = new ArrayList<>();
        List<Integer> tileIndexes = new ArrayList<>();
        HashMap<Integer, Integer> map = new HashMap<>();
        
        // First is the empty tile:
        tileIndexes.add(0);
        map.put(0, 0);
        tiles.add(getTile(img, 0, 0));
        
        for(int room[][]: new int[][][]{room1, room2, room3}) {
            for(int j = 0;j<room[0].length;j++) {
                for(int i = 0;i<room.length;i++) {
                    int tile_idx = room[i][j];
                    if (!tileIndexes.contains(tile_idx)) {
                        int y = tile_idx/width;
                        int x = tile_idx%width;
                        List<Integer> tile = getTile(img, x, y);
                        int found = -1;
                        for(int k = 0;k<tiles.size();k++) {
                            List<Integer> tile2 = tiles.get(k);
                            if (tile.equals(tile2)) {
                                found = k;
                                break;
                            }
                        }
                        if (found == -1) {
                            map.put(tile_idx, tiles.size());
                            tiles.add(tile);
                            tileIndexes.add(tile_idx);
                        } else {
                            map.put(tile_idx, found);
                        }
                    }
                }
            }
        }
        System.out.println("# tiles: " + tileIndexes.size());
        System.out.println("tiles: " + tileIndexes);
        
        // Find similar:
        findSimilarTiles(tiles);
        
        // Generate a tiles image:
        BufferedImage tilesImage = generateTilesImage(tiles, 16);
        ImageIO.write(tilesImage, "png", new File("data/tiled-rooms/tmp.png"));
        
        // Save data:
        List<Integer> dataTiles = new ArrayList<>();
        for(int i = 0;i<tiles.size();i++) {
            int y = i/16;
            int x = i%16;
            dataTiles.addAll(ConvertPatternsToAssembler.generateAssemblerPatternBitmap(x, y, tilesImage, TOLERANCE));
            dataTiles.addAll(ConvertPatternsToAssembler.generateAssemblerPatternAttributes(x, y, tilesImage, TOLERANCE));
        }
        String outputFileName1 = "src/autogenerated/tiled-rooms/street1-tiles";
        Z80Assembler.dataToBinary(dataTiles, outputFileName1+".bin");    
        ZX0Wrapper.main(outputFileName1+".bin", outputFileName1+".zx0", true, false);

        List<Integer> dataNameTable = new ArrayList<>();
        for(int room[][]: new int[][][]{room1, room2, room3}) {
            for(int j = 0;j<room[0].length;j++) {
                for(int i = 0;i<room.length;i++) {
                    dataNameTable.add(map.get(room[i][j]));
                }
            }
        }
        String outputFileName2 = "src/autogenerated/tiled-rooms/street-nametables";
        Z80Assembler.dataToBinary(dataNameTable, outputFileName2+".bin");    
        ZX0Wrapper.main(outputFileName2+".bin", outputFileName2+".zx0", true, false);
    }

    private static BufferedImage generateTilesImage(List<List<Integer>> tiles,
                                                    int tilesPerRow) throws Exception {
        int width = tilesPerRow*8;
        int height = ((tiles.size()+tilesPerRow-1)/tilesPerRow)*8;
        
        BufferedImage tilesImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        for(int i = 0;i<tiles.size();i++) {
            int x = (i%tilesPerRow);
            int y = (i/tilesPerRow);
            drawTile(tilesImg, tiles.get(i), x, y);
        }
        return tilesImg;
    }
    
    
    public static List<Integer> getTile(BufferedImage img, int x, int y) throws Exception {
        List<Integer> tile = new ArrayList<>();
        for(int i = 0;i<8;i++) {
            List<Integer> pixels = ConvertPatternsToAssembler.patternColors(x, y, i, img, TOLERANCE);
            tile.addAll(pixels);
        }
        return tile;
    }

    
    public static void drawTile(BufferedImage img, List<Integer> tile, int x, int y)
    {
        for(int i = 0;i<tile.size();i++) {
            int image_x = x*8 + i%8;
            int image_y = y*8 + i/8;
            int color = tile.get(i);
            int a = 255;
            if (image_x >= img.getWidth() ||
                image_y >= img.getHeight()) {
//                System.err.println("pixel out of bounds!");
                throw new Error("pixel out of bounds!");
            } else {
                img.setRGB(image_x, image_y, ConvertPatternsToAssembler.MSX1Palette[color][2] + (ConvertPatternsToAssembler.MSX1Palette[color][1]<<8) + (ConvertPatternsToAssembler.MSX1Palette[color][0]<<16) + (a<<24));
            }
        }
    }

    private static void findSimilarTiles(List<List<Integer>> tiles) {
        for(int i = 0;i<tiles.size();i++) {
            List<Integer> tile = tiles.get(i);
            for(int j = i+1;j<tiles.size();j++) {
                List<Integer> tile2 = tiles.get(j);
                int diff = 0;
                for(int k = 0;k<8*8;k++) {
                    if (!tile.get(k).equals(tile2.get(k))) {
                        diff++;
                    }
                }
                if (diff <= 2) {
                    System.out.println("Tile " + i + " and " + j + " differ only in " + diff);
                }
            }
        }
    }
}
